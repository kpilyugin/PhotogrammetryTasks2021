В этом репозитории предложены задания для курса по фотограмметрии в [CSCenter](https://compscicenter.ru/courses/photogrammetry/) и [CSClub](https://compsciclub.ru/courses/photogrammetry/).

[Остальные задания](https://github.com/PhotogrammetryCourse/PhotogrammetryTasks2021/).

# Задание 6. Build model. Triangulation Delaunay + Graph Min-Cut

[![Build Status](https://travis-ci.com/PhotogrammetryCourse/PhotogrammetryTasks2021.svg?branch=task06)](https://travis-ci.com/PhotogrammetryCourse/PhotogrammetryTasks2021)

0. Скачать и распаковать в папки data/src/datasets/ карты глубины: [saharov32](https://disk.yandex.com/d/2fWAdzpM4ibYBg), [herzjesu25](https://disk.yandex.com/d/n3MyKUjvuVPF6Q)

1. Установить CGAL - см. комментарии после ```find_package(CGAL ...)``` в корневом CMakeLists.txt

2. Проглядеть тест в tests/test_mesh_min_cut.cpp:

 - Он грузит датасет DATASET_DIR уменьшая картинки в DATASET_DOWNSCALE раз
 - Считывает информацию о расположениях камер и ключевых точек из заранее подготовленных cameras.out файлов
 - Загружает карты глубины (.exr-файлы с float32 глубиной в каждом пикселе, на самом деле это не глубина, а координата по оси Z)
 - Сохраняет ply-файл визуализирующий расположения камер и ключевых тчоек в data/debug/test_mesh_min_cut/FromAllDepthMaps
 - Сохраняет ply-файлы визуализирующие каждое облако точек построенное по картам глубины (тривиальной репроекцией точки в глобальное пространство)
 - **TODO 1001** запустите test_mesh_min_cut/DepthMapsToPointClouds и убедитесь что облака точек построенные по картам глубины выглядят правдоподобно

3. Проглядеть тесты test_mesh_min_cut/FromSingleDepthMap и test_mesh_min_cut/FromAllDepthMaps:

 - **TODO 1002** запустите test_mesh_min_cut/FromAllDepthMaps и убедитесь что полигональные модели построенные по картам глубины выглядят правдоподобно и например для DATASET_DIR=saharov32, DATASET_DOWNSCALE=4, CAMERAS_LIMIT=5 выглядит похоже на это:

![saharov32_4_5](/.github/screens/saharov32_4_5.jpg?raw=true)

То что модель облеплена несколькими огромными треугольниками - пока что нормально т.к. вызвано фиктивным bounding box который добавлен в методе insertBoundingBoxVertices (см. ниже его описание и так же позже см. TODO 2002)
 
4. Проглядеть структуру кода в файле src/phg/mvs/model_min_cut/min_cut_model_builder.h содержащий MinCutModelBuilder, в нем самые важные функции:

 - ```appendToTriangulation()``` - добавить очередную карту глубины в триангуляцию (вставка точек с возможным объединением их с уже существующими + сохранение положения камеры)
 - ```buildMesh()``` - на базе всех добавленных карт глубины - протрассировать лучи видимости от точек к камерам чтобы построить пропускные способности для ребер графа, затем найти минимальный разрез, затем извлечь его ввиде полигональной модели
 - ```insertBoundingBoxVertices()```- для простоты - ограничим всю нашу триангуляцию большим кубом (bounding box), в таком случае нам не придется поддерживать крайние случаи с бесконечно удаленной точкой (и соответственно с бесконечно большими треугольниками) 

5. Разобраться в методе appendToTriangulation() в src/phg/mvs/model_min_cut/min_cut_model_builder.cpp

 - **TODO 2001** appendToTriangulation(): реализуйте нормальную проверку объединять ли точку с уже добавленной ранее (с учетом r и MERGE_THRESHOLD_RADIUS_KOEF)
 - **TODO 2002** добавьте проверку - не опирается ли треугольник на одну из фиктивных вершин (лежащих на гранях вспомогательного bounding box), можете для этого использовать bb_min и bb_max, или добавьте явный флаг в каждую вершину
 - **TODO 2003** некоторые треугольники выглядят темными в результирующей модели, проблема уходит если выключить в MeshLab освещение (кнопка желтой лампочка - Light on/off) которое учитывает нормаль, которая строится с учетом порядка вершин треугольника (по часовой стрелке или против)
 - **TODO 2004** подумайте и напишите тут какие вершины бывают без камер вообще? почему мы их пропускаем? что и почему случится если убрать это пропускание?
 - **TODO 2005** изменится ли что-то если сильно увеличить пропускные способности ребер от истока? (т.е. сделать пропускную способность из истока равной бесконечности?)

Выполнение TODO до сюда - примерно **3/10** баллов.

6. Разобраться в методе buildMesh() в src/phg/mvs/model_min_cut/min_cut_model_builder.cpp

Вспомогательная иллюстрация:

![saharov32_4_5](/.github/screens/triangulation_ray_tracing.png?raw=true)

Если что-то непонятно - смело спрашивайте в чате, даже (особенно) если вопрос простой.

7. Реализация второй статьи [labatut2009](https://compsciclub.ru/courses/photogrammetry/2021-spring/classes/6940/) на 4 балла (т.е. примерно **7/10**)):

 - **TODO 3001** сделайте пропускные способности на ребрах не единичными а затухающими тем сильнее чем ближе к поверхности
 - **TODO 3002** сделайте соединение со стоком в ячейке не сразу за вершиной, а на небольшом углублении (пропорционально размеру точки)

8. Реализация третьей статии на 1 балл (т.е. примерно **8/10**):

 - **TODO 3500** Weak support: реализуйте идею из [jancosek2011 - Multi-View Reconstruction Preserving Weakly-Supported Surfaces](https://compsciclub.ru/attachments/classes/file_XyLpDjLx/jancosek2011.pdf)

9. Небольшие эксперименты на 1 балл (т.е. примерно **9/10**):

 - **TODO 4001** подвиньте вершины в среднюю координату среди всех точек которые в ней зачлись
 - **TODO 4002** поэкспериментируйте со значением MERGE_THRESHOLD_RADIUS_KOEF, есть ли интересности? какое значение вы бы предложили использовать в условной финальной версии?
 - **TODO 4003** добавьте усреднение цветов среди всех склеившихся вершин, приложите скриншот с/без усреднения
 
10. Доп. задание на 2 балла (т.е. примерно **11/10**) на ускорение кода:

 - **TODO 5001** как в целом можно ускорить реализацию? есть ли идеи? попробуйте это сделать (и запишите какого ускорения получилось добиться, а так же изменился ли результат)
 - **TODO 5002** а не рапараллелить ли? если будете распараллеливать - убедитесь что вы заменили triangulation.incident_cells() на triangulation.incident_cells_threadsafe()
 - **TODO 5003** не слишком ли часто вызывается triangulation.locate()? может оно тормозит? (поиск ячейки содержащей заданную точку)
 - **TODO 5004** CGAL::do_intersect() проверяет луч и треугольник на пересечение абсолютно точно, и это надежно, но медленно. А что если мы грубо будем проверять пересечения (самописным простым кодом на float-ах)? А когда пересечение не факт что произошло - ну что же, пусть этому лучу не повезло, будем надеяться это не сильно изменит результат? Попробуйте и сравните скорость и результат.

11. Отправить **Pull-request** с названием```Task06 <Имя> <Фамилия> <Аффиляция>```:

 - Скопируйте в описание [шаблон](https://raw.githubusercontent.com/PhotogrammetryCourse/PhotogrammetryTasks2021/task06/.github/pull_request_template.md)
 - Обязательно отправляйте PR из вашей ветки **task06** (вашего форка) в ветку **task06** (основного репозитория)
 - Перечислите свои мысли по вопросам поднятым в коде и просто появившиеся в процессе выполнения задания
 - Создайте PR
 - Перечислите успешно выполненные TODO, если какие-то в попробовали сделать, приложили существенное количество усилий но не вышло - расскажите об этоим
 - Приложите скриншоты результатов (тех что понравились больше всего, или может в концепте "сделал такое-то изменение, разница результата очень впечатлила, вот скрин ДО, вот скрин ПОСЛЕ!")
 
Про MeshLab:

 - Если дважды кликнуть мышкой - шарик вращения сфокусируется на месте клика, и туда будет легче призумиться
 - Alt+колесо мышки позволяет настроить размер точек
 - Render->Show Vertex Normals покажет нормали точек
 - Переключиться в режим отрисовки геометрии/цвета: Render->Color->None/Per Vertex
 - Включить/выключить освещение (учитывать нормали треугольников или нет) - желтая лампочка сверху - Light on/off

**Дедлайн**: 19:55 20 апреля
